##########################################################################
#
#          MPU6050 driver using Digital Motion Processing
# (see: https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/MPU6050)     
#   
##########################################################################
from machine import SoftI2C, Pin
from time import sleep_ms
from struct import pack, unpack
from math import atan, atan2, asin
import sys

GRAVITIY_MS2 = 9.80665

MPU6050_RA_XG_OFFS_TC              = const(0x00)
MPU6050_RA_YG_OFFS_TC              = const(0x01)
MPU6050_RA_ZG_OFFS_TC              = const(0x02)
MPU6050_RA_XA_OFFS_H               = const(0x06)
MPU6050_RA_YA_OFFS_H               = const(0x08)
MPU6050_RA_ZA_OFFS_H               = const(0x0A)
MPU6050_RA_XG_OFFS_USRH            = const(0X13)
MPU6050_RA_YG_OFFS_USRH            = const(0X15)
MPU6050_RA_ZG_OFFS_USRH            = const(0X17)
MPU6050_RA_SMPLRT_DIV              = const(0x19)
MPU6050_RA_CONFIG                  = const(0x1A)
MPU6050_RA_GYRO_CONFIG             = const(0x1B)
MPU6050_RA_ACCEL_CONFIG            = const(0x1C)
MPU6050_RA_MOT_THR                 = const(0x1F)
MPU6050_RA_MOT_DUR                 = const(0x20)
MPU6050_RA_ZRMOT_THR               = const(0x21)
MPU6050_RA_ZRMOT_DUR               = const(0x22)
MPU6050_RA_I2C_SLV0_ADDR           = const(0X25)
MPU6050_RA_INT_ENABLE              = const(0x38)
MPU6050_RA_INT_STATUS              = const(0x3A)
MPU6050_RA_ACCEL_XOUT_H            = const(0x3B)
MPU6050_RA_ACCEL_YOUT_H            = const(0x3D)
MPU6050_RA_ACCEL_ZOUT_H            = const(0x3F)
MPU6050_RA_GYRO_XOUT_H             = const(0x43)
MPU6050_RA_GYRO_YOUT_H             = const(0x45)
MPU6050_RA_GYRO_ZOUT_H             = const(0x47)
MPU6050_RA_USER_CTRL               = const(0x6A)
MPU6050_RA_PWR_MGMT_1              = const(0x6B)
MPU6050_RA_PWR_MGMT_2              = const(0x6C)
MPU6050_RA_BANK_SEL                = const(0x6D)
MPU6050_RA_MEM_START_ADDR          = const(0x6E)
MPU6050_RA_MEM_R_W                 = const(0x6F)
MPU6050_RA_DMP_CFG_1               = const(0x70)
MPU6050_RA_DMP_CFG_2               = const(0x71)
MPU6050_RA_FIFO_COUNTH             = const(0x72)
MPU6050_RA_FIFO_R_W                = const(0x74)
MPU6050_PWR1_CLKSEL_BIT            = const(2)
MPU6050_PWR1_CLKSEL_LENGTH         = const(3)
MPU6050_PWR1_SLEEP_BIT             = const(6)
MPU6050_PWR1_DEVICE_RESET_BIT      = const(7)
MPU6050_CLOCK_PLL_ZGYRO            = const(0x03)
MPU6050_INTERRUPT_FIFO_OFLOW_BIT   = const(4)
MPU6050_INTERRUPT_DMP_INT_BIT      = const(0)
MPU6050_EXT_SYNC_TEMP_OUT_L        = const(0x1)
MPU6050_DLPF_BW_42                 = const(0x03)
MPU6050_GYRO_FS_2000               = const(0x03)
MPU6050_ACCEL_FS_2G                = const(0)
MPU6050_DMP_CODE_SIZE              = const(1929)
MPU6050_DMP_FIFO_RATE_DIVISOR      = const(0x01)
MPU6050_DMP_MEMORY_CHUNK_SIZE      = const(16)
MPU6050_USERCTRL_I2C_MST_RESET_BIT = const(1)
MPU6050_USERCTRL_FIFO_RESET_BIT    = const(2)
MPU6050_USERCTRL_DMP_RESET_BIT     = const(3)
MPU6050_USERCTRL_I2C_MST_EN_BIT    = const(5)
MPU6050_USERCTRL_FIFO_EN_BIT       = const(6)
MPU6050_USERCTRL_DMP_EN_BIT        = const(7)
MPU6050_CFG_EXT_SYNC_SET_BIT       = const(5)
MPU6050_CFG_EXT_SYNC_SET_LENGTH    = const(3)
MPU6050_CFG_DLPF_CFG_BIT           = const(2)
MPU6050_CFG_DLPF_CFG_LENGTH        = const(3)
MPU6050_GCONFIG_FS_SEL_BIT         = const(4)
MPU6050_GCONFIG_FS_SEL_LENGTH      = const(2)
MPU6050_TC_OTP_BNK_VLD_BIT         = const(0)
MPU6050_TC_OFFSET_BIT              = const(6)
MPU6050_TC_OFFSET_LENGTH           = const(6)
MPU6050_FIFO_DEFAULT_TIMEOUT       = const(11000)


dmpMemory = bytes([
# bank  0 
0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCB, 0x47, 0xA2, 0x20, 0x00, 0x00, 0x00,
0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
# bank  1
0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x09, 0x23, 0xA1, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
0x80, 0x00, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
# bank 2
0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x01, 0x00, 0x05, 0x8B, 0xC1, 0x00, 0x00, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
# bank 3
0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0x4C, 0xCD, 0x6C, 0xA9, 0x0C,
0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
# bank 4
0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
# bank 5
0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,
# bank 6
0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,
# bank 7
0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
0xDD, 0xF1, 0x20, 0x28, 0x30, 0x38, 0x9A, 0xF1, 0x28, 0x30, 0x38, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0x28, 0x30, 0x38,
0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0x30, 0xDC,
0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xFE, 0xD8, 0xFF])

def meanSensors(mpu, bufferSize=1000):
    buff_ax, buff_ay, buff_az = 0, 0, 0
    buff_gx, buff_gy, buff_gz = 0, 0, 0

    for i in range(100):  # do not use the first 100 reading
        try:
            mpu.getAccelRaw()
            mpu.getGyroRaw()
        except:
            pass
    
    naccel, nrot = 0, 0

    while naccel < bufferSize or nrot < bufferSize:
        if naccel < bufferSize:
            try:
                ax, ay, az = mpu.getAccelRaw()
                buff_ax += ax
                buff_ay += ay
                buff_az += az
                naccel += 1
            except:
                pass
        if nrot < bufferSize:
            try:
                gx, gy, gz = mpu.getGyroRaw()
                buff_gx += gx
                buff_gy += gy
                buff_gz += gz
                nrot += 1
            except:
                pass

    mean_ax = buff_ax//bufferSize
    mean_ay = buff_ay//bufferSize
    mean_az = buff_az//bufferSize
    mean_gx = buff_gx//bufferSize
    mean_gy = buff_gy//bufferSize
    mean_gz = buff_gz//bufferSize

    return mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz

class MPU6050dmp():
    
    def __init__(self, i2c, axOff=None, ayOff=None, azOff=None, gxOff=None, gyOff=None, gzOff=None):
        self.addr = 0x68
        self.i2c = i2c
        if self.addr not in self.i2c.scan():
            print('********** MPU6050dmp init : MPU6050 not found')
            return
        print('********** MPU6050dmp init : MPU6050 found address 0x68')
        self.reset()
        sleep_ms(100)
        self.setSleepEnabled(False)
        if axOff: self.setXAccelOffset(axOff)
        if ayOff: self.setYAccelOffset(ayOff)
        if azOff: self.setZAccelOffset(azOff)
        if gxOff: self.setXGyroOffset(gxOff)
        if gyOff: self.setYGyroOffset(gyOff)
        if gzOff: self.setZGyroOffset(gzOff)
    
    def readBit(self, reg_addr, bitNum):
        b = self.i2c.readfrom_mem(self.addr, reg_addr, 1)[0]
        return (b & (1 << bitNum)) >> bitNum
    
    def readBits(self, reg_addr, bitStart, length):
        b = self.readByte(self, reg_addr)
        mask = ((1 << length) - 1) << (bitStart - length + 1)
        b &= mask
        b >>= (bitStart - length + 1)
        return b
        
    def readByte(self, reg_addr):
        b = self.i2c.readfrom_mem(self.addr, reg_addr, 1)[0]
        return b
    
    def writeBit(self, reg_addr, bit_pos, enabled):
        b = self.i2c.readfrom_mem(self.addr, reg_addr, 1)[0]
        if enabled:
            b |= 1 << bit_pos
        else:
            b &= ~( 1 << bit_pos)
        self.i2c.writeto_mem(self.addr, reg_addr, bytes([b]))
    
    def writeBits(self, reg_addr, bitStart, length,  data):
        b = self.i2c.readfrom_mem(self.addr, reg_addr, 1)[0]
        mask = ((1 << length) - 1) << (bitStart - length + 1)
        data <<= (bitStart - length + 1)
        data &= mask
        b &= ~(mask)
        b |= data
        return self.writeByte(reg_addr, b)
        
    def writeByte(self, reg_addr, data):
        self.i2c.writeto_mem(self.addr, reg_addr, bytes([data]))
        return True
    
    def writeWord(self, regAddr, data):
        self.i2c.writeto_mem(self.addr, regAddr, bytes([data & 0xff, data >> 8]))
        
    def reset(self):
        self.writeBit(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_DEVICE_RESET_BIT, True)
        
    def dmpInitialize(self, debug=False):
        #
        if debug: print('************ DMP initialize : starting initialization')
        #
        accelOffsets = self.getAccelOffsets()
        gyroOffsets  = self.getGyroOffsets()
        if debug: print('                              accel and gyro offsets saved')
        self.reset()
        if debug: print('                              device reset')
        sleep_ms(30)
        self.setSleepEnabled(False)
        if debug:
            print('                              device wake up')
            self.setMemoryBank(0x10, True, True)
            self.setMemoryStartAddress(0x06)
            if debug: print('                              Revision @ user[16][6] = ',
              self.readByte(MPU6050_RA_MEM_R_W))
        self.setMemoryBank(0, False, False)
        if debug: print('                              memory bank set to 0')
#         self.setSlaveAddress(0, 0x7F)
#         self.setI2CMasterModeEnabled(False)
#         self.setSlaveAddress(0, 0x68)
#         self.resetI2CMaster()
        sleep_ms(20)
        self.setClockSource(MPU6050_CLOCK_PLL_ZGYRO)
        if debug: print('                              device clock = PLL_ZGYRO')
        self.setIntEnabled((1<<MPU6050_INTERRUPT_FIFO_OFLOW_BIT)|                 
                           (1<<MPU6050_INTERRUPT_DMP_INT_BIT))
        if debug: print('                              interrupt enabled = FIFO_OFLOW')
        self.setRate(4)
        if debug: print('                              sampling rate = 100Hz')
        self.setExternalFrameSync(MPU6050_EXT_SYNC_TEMP_OUT_L)
        if debug: print('                              setExternalFrameSync')
        self.setDLPFMode(MPU6050_DLPF_BW_42)
        if debug: print('                              digital low-pass filter = 42Hz')
        self.setFullScaleGyroRange(MPU6050_GYRO_FS_2000)
        if debug: print('                              gyro full scale = +/-2000deg/s')
        self.setAccelRange(MPU6050_ACCEL_FS_2G)
        if debug: print('                              accel full range = +/2g')
        if not self.writeProgMemory(dmpMemory, debug):
            print('********* MPU6050.dmpInitialize : error loading program memory, abort dmp initialisation')
            return False
        if debug: print('                              DMP program memory loaded')
        self.setDMPConfig1(0x03)
        if debug: print('                              config register 1 = 0x03')
        self.setDMPConfig2(0x00)
        if debug: print('                              config register 2 = 0x00')
        self.setOTPBankValid(False)
        if debug: print('                              OTPBankValid = False')
        self.setMotionDetectionThreshold(2)
        if debug: print('                              Motion detection threshold = 2')
        self.setZeroMotionDetectionThreshold(156)
        if debug: print('                              Zero motion detection threshold = 156')
        self.setMotionDetectionDuration(80)
        if debug: print('                              Motion detection duration = 80')
        self.setZeroMotionDetectionDuration(0)
        if debug: print('                              Zero motion detection duration = 0')
        self.setFIFOEnabled(True)
        if debug: print('                              FIFI enabled')
        self.resetDMP()
        if debug: print('                              DMP reset')
        self.setDMPEnabled(False)
        if debug: print('                              DMP disabled')
        self.dmpPacketSize = 42
        self.resetFIFO()
        if debug: print('                              FIFO reset')
        self.getIntStatus()
        if debug: print('                              interrupt status register cleared')
        self.setAccelOffsets(*accelOffsets)
        self.setGyroOffsets(*gyroOffsets)
        if debug: print('                              accel and gyro offsets restored')
        #
        if debug: print('************ DMP initialize : initialization end')
        return True
    
    def setSleepEnabled(self, enabled=True):
        self.writeBit(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, enabled)
    
    def setMemoryBank(self, bank, prefetchEnabled=False, userBank=False):
        bank &= 0x1F
        if userBank: bank |= 0x20
        if prefetchEnabled: bank |= 0x40
        self.writeByte(MPU6050_RA_BANK_SEL, bank)
    
    def getOTPBankValid(self):
        return self.readBit(MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT)
                     
    def setMemoryStartAddress(self, address):
        self.writeByte(MPU6050_RA_MEM_START_ADDR, address)
    
    def getOTPBankValid(self):
        return self.readBit(MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT)
    
    def setI2CMasterModeEnabled(self, enabled):
        self.writeBit(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, enabled)
    
    def setSlaveAddress(self, num, address):
        if num > 3: return
        self.writeByte(MPU6050_RA_I2C_SLV0_ADDR + num*3, address)
    
    def resetI2CMaster(self):
        self.writeBit(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_RESET_BIT, True)
    
    def setClockSource(self, source):
        self.writeBits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT,
                       MPU6050_PWR1_CLKSEL_LENGTH, source)
    
    def setIntEnabled(self, enabled):
        self.writeByte(MPU6050_RA_INT_ENABLE, enabled)
    
    def setRate(self, rate):
        self.writeByte(MPU6050_RA_SMPLRT_DIV, rate)
    
    def setExternalFrameSync(self, sync):
        self.writeBits(MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT,
                        MPU6050_CFG_EXT_SYNC_SET_LENGTH, sync)
    
    def setDLPFMode(self, mode):
        self.writeBits(MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT,
                       MPU6050_CFG_DLPF_CFG_LENGTH, mode)
    
    def setFullScaleGyroRange(self, rng):
        self.writeBits(MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT,
                       MPU6050_GCONFIG_FS_SEL_LENGTH, rng)
    
    def setAccelRange(self, rng):
        self.i2c.writeto_mem(self.addr, MPU6050_RA_ACCEL_CONFIG, bytes([rng]))
        
    def writeProgMemory(self, data, debug=False):
        if debug: print('---------------------------------- start writing program memory')          
        for bank in range(8):
            k, success = 3, False
            while k and not success:                    # try 3 times for each bank
                self.writeMemoryBank(bank, data, debug)
                sleep_ms(20)
                if self.checkMemoryBank(bank, data, debug):
                    sleep_ms(20)
                    if debug: print('                 bank {} ok'.format(bank))
                    success = True
                else:
                    print('   error writing bank {}'.format(bank))
                k -= 1
            if not success: return False
        return True
    
    def writeMemoryBank(self, bank, data, debug=False):
        self.setMemoryBank(bank)
        self.setMemoryStartAddress(0)
        startind = bank*256
        stopind  = min(startind+256, len(data))
        self.i2c.writeto_mem(self.addr, MPU6050_RA_MEM_R_W, data[startind:stopind])
        if debug: print('   writing bank       {} dmpMemory[{:4d}:{:4d}]'.format(bank, startind, stopind))
    
    def checkMemoryBank(self, bank, data, debug=False):
        self.setMemoryBank(bank)
        self.setMemoryStartAddress(0)
        startind = bank*256
        stopind  = min(startind+256, len(data))
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_MEM_R_W, stopind-startind)
        if debug: print('   checking bank      {}          [{:4d}:{:4d}]'.format(bank, startind, stopind))
        return buf == data[startind:stopind]
    
    def checkPgmMemory(self):
        for bank in range(8):
            sleep_ms(20)
            if self.checkMemoryBank(bank, dmpMemory):
                print('memory bank {} ok'.format(bank))
            else:
                print('memory bank {} corrupted'.format(bank))
    
    def setDMPConfig1(self, config):
        self.writeByte(MPU6050_RA_DMP_CFG_1, config)
    
    def setDMPConfig2(self, config):
        self.writeByte(MPU6050_RA_DMP_CFG_2, config)
    
    def setOTPBankValid(self, enabled):
        self.writeBit(MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, enabled)
    
    def setMotionDetectionThreshold(self, threshold):
        self.writeByte(MPU6050_RA_MOT_THR, threshold)
    
    def setZeroMotionDetectionThreshold(self, threshold):
        self.writeByte(MPU6050_RA_ZRMOT_THR, threshold)
    
    def setMotionDetectionDuration(self, duration):
        self.writeByte(MPU6050_RA_MOT_DUR, duration)
    
    def setZeroMotionDetectionDuration(self, duration):
        self.writeByte(MPU6050_RA_ZRMOT_DUR, duration)
    
    def setFIFOEnabled(self, enabled):
        self.writeBit(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, enabled)
    
    def resetDMP(self):
        self.writeBit(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_RESET_BIT, True)
    
    def setDMPEnabled(self, enabled):
        self.writeBit(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enabled)
    
    def resetFIFO(self):
        self.writeBit(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, True)
    
    def getIntStatus(self):
        return self.readByte(MPU6050_RA_INT_STATUS)
    
    def getXAccelRaw(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_ACCEL_XOUT_H, 2)
        ax = unpack('>h', buf)[0]  # signed 16 bits integer
        return ax
    
    def getYAccelRaw(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_ACCEL_YOUT_H, 2)
        ay = unpack('>h', buf)[0]  # signed 16 bits integer
        return ay
    
    def getZAccelRaw(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_ACCEL_ZOUT_H, 2)
        az = unpack('>h', buf)[0]  # signed 16 bits integer
        return az
    
    def getAccelRaw(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_ACCEL_XOUT_H, 6)
        ax, ay, az = unpack('>hhh', buf)
        return ax, ay, az
        
    def getXGyroRaw(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_GYRO_XOUT_H, 2)
        gx = unpack('>h', buf)[0]  # signed 16 bits integer
        return gx
    
    def getYGyroRaw(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_GYRO_YOUT_H, 2)
        gy = unpack('>h', buf)[0]  # signed 16 bits integer
        return gy
    
    def getZGyroRaw(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_GYRO_ZOUT_H, 2)
        gz = unpack('>h', buf)[0]  # signed 16 bits integer
        return gz

    def getGyroRaw(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_GYRO_XOUT_H, 6)
        gx, gy, gz = unpack('>hhh', buf)
        return gx, gy, gz

    def getXAccelOffset(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_XA_OFFS_H, 2)
        axOff = unpack('>h', buf)[0]  # signed 16 bits integer
        return axOff

    def getYAccelOffset(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_YA_OFFS_H, 2)
        ayOff = unpack('>h', buf)[0]  # signed 16 bits integer
        return ayOff

    def getZAccelOffset(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_ZA_OFFS_H, 2)
        azOff = unpack('>h', buf)[0]  # signed 16 bits integer
        return azOff
    
    def getAccelOffsets(self):
        return self.getXAccelOffset(), self.getYAccelOffset(), self.getZAccelOffset()

    def setXAccelOffset(self, offset):
        bit0 = self.i2c.readfrom_mem(self.addr, MPU6050_RA_XA_OFFS_H + 1, 1)[0] & 0x01
        offset = (offset & 0xfffe) | bit0
        buf = pack('>h', offset)  # signed 16 bits integer
        self.i2c.writeto_mem(self.addr, MPU6050_RA_XA_OFFS_H, buf)
    
    def setYAccelOffset(self, offset):
        bit0 = self.i2c.readfrom_mem(self.addr, MPU6050_RA_YA_OFFS_H + 1, 1)[0] & 0x01
        offset = (offset & 0xfffe) | bit0
        buf = pack('>h', offset)  # signed 16 bits integer
        self.i2c.writeto_mem(self.addr, MPU6050_RA_YA_OFFS_H, buf)
    
    def setZAccelOffset(self, offset):
        bit0 = self.i2c.readfrom_mem(self.addr, MPU6050_RA_ZA_OFFS_H + 1, 1)[0] & 0x01
        offset = (offset & 0xfffe) | bit0
        buf = pack('>h', offset)  # signed 16 bits integer
        self.i2c.writeto_mem(self.addr, MPU6050_RA_ZA_OFFS_H, buf)
    
    def setAccelOffsets(self, axOff, ayOff, azOff):
        self.setXAccelOffset(axOff)
        self.setYAccelOffset(ayOff)
        self.setZAccelOffset(azOff)
        
    def getXGyroOffset(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_XG_OFFS_USRH, 2)
        gxOff = unpack('>h', buf)[0]  # signed 16 bits integer
        return gxOff

    def getYGyroOffset(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_YG_OFFS_USRH, 2)
        gyOff = unpack('>h', buf)[0]  # signed 16 bits integer
        return gyOff

    def getZGyroOffset(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_ZG_OFFS_USRH, 2)
        gzOff = unpack('>h', buf)[0]  # signed 16 bits integer
        return gzOff
    
    def getGyroOffsets(self):
        return self.getXGyroOffset(), self.getYGyroOffset(), self.getZGyroOffset()

    def setXGyroOffset(self, offset):
        buf = pack('>h', offset)  # signed 16 bits integer
        self.i2c.writeto_mem(self.addr, MPU6050_RA_XG_OFFS_USRH, buf)
    
    def setYGyroOffset(self, offset):
        buf = pack('>h', offset)  # signed 16 bits integer
        self.i2c.writeto_mem(self.addr, MPU6050_RA_YG_OFFS_USRH, buf)
    
    def setZGyroOffset(self, offset):
        buf = pack('>h', offset)  # signed 16 bits integer
        self.i2c.writeto_mem(self.addr, MPU6050_RA_ZG_OFFS_USRH, buf)
    
    def setGyroOffsets(self, gxOff, gyOff, gzOff):
        self.setXGyroOffset(gxOff)
        self.setYGyroOffset(gyOff)
        self.setZGyroOffset(gzOff)
        
    def resetFIFO(self):
        self.writeBit(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, True)
        
    def getFIFOCount(self):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_FIFO_COUNTH, 2)
        count = unpack('>H', buf)[0]
        return count
        
    def getFIFOBytes(self, length):
        buf = self.i2c.readfrom_mem(self.addr, MPU6050_RA_FIFO_R_W, length)
        return buf
    
    def dmpGetQuaternion(self, fifoBuffer):
        qw = unpack('>h', fifoBuffer[:2])[0]/16384
        qx = unpack('>h', fifoBuffer[4:6])[0]/16384
        qy = unpack('>h', fifoBuffer[8:10])[0]/16384
        qz = unpack('>h', fifoBuffer[12:14])[0]/16384
        return qw, qx, qy, qz
    
    def dmpGetFifoGyro(self, fifoBuffer):
        gx = unpack('>h', fifoBuffer[16:18])[0]/16.4
        gy = unpack('>h', fifoBuffer[20:22])[0]/16.4
        gz = unpack('>h', fifoBuffer[24:26])[0]/16.4
        return gx, gy, gz
    
    def dmpGetFifoAccel(self, fifoBuffer):
        ax = unpack('>h', fifoBuffer[28:30])[0]/8192
        ay = unpack('>h', fifoBuffer[32:34])[0]/8192
        az = unpack('>h', fifoBuffer[36:38])[0]/8192
        return ax, ay, az
    
    def dmpGetLinearAcc(self, grav, acc):
        lax = acc[0] - grav[0]
        lay = acc[1] - grav[1]
        laz = acc[2] - grav[2]
        return lax, lay, laz        
    
    def dmpGetGravity(self, quat):
        qw, qx, qy, qz = quat
        gx = 2 * (qx*qz - qw*qy)
        gy = 2 * (qw*qx + qy*qz)
        gz = (qw**2 - qx**2 - qy**2 + qz**2)
        return gx, gy, gz
    
    def dmpGetYawPitchRoll(self, quat, grav):
        qw, qx, qy, qz = quat
        gx, gy, gz = grav
        yaw = atan2(2*qx*qy - 2*qw*qz, 2*qw**2 - 2*qx**2 - 1)
        if (gy**2 + gz**2) != 0.:
            pitch = atan(gx / (gy**2 + gz**2))
            roll = atan( gy / (gx**2 + gz**2))
        else:
            print('****** dmpGetYawPitchRoll: zero division error: q:{}  g:{}'.format(quat, grav))
            raise Exception(ZeroDivisionError)
        return yaw, pitch, roll
    
    def dmpGetEuler(self, quat):
        qw, qx, qy, qz = quat
        psi   = atan2(2*qx*qy - 2*qw*qz, 2*qw**2 + 2*qx**2 - 1)
        phi   = atan2(2*qy*qz - 2*qw*qx, 2*qw**2 + 2*qz**2 - 1)
        theta = -asin(2*qx*qz + 2*qw*qy)
        return theta, phi, psi
    
    def calibrate(self):
        accel_deadzone = 8
        gyro_deadzone  = 1
        self.setAccelOffsets(0, 0, 0)
        self.setGyroOffsets(0, 0, 0)
        mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz = meanSensors(self)
        
        ax_offset = -mean_ax//8  # actual accel offset = stored value X 8 (?)
        ay_offset = -mean_ay//8
        az_offset = (16384-mean_az)//8
        gx_offset = -mean_gx//4  # actual gyro offset = stored value X 4 (?)
        gy_offset = -mean_gy//4
        gz_offset = -mean_gz//4
        
        print('******* MPU6050 calibration init  - Hit CTRL-C to stop')
        print('ax:{:5d} ay:{:5d} az:{:5d} gx:{:5d} gy:{:5d} gz:{:5d}'.format(ax_offset, ay_offset, az_offset, gx_offset, gy_offset, gz_offset))
        
        ax_ok, ay_ok, az_ok = False, False, False
        gx_ok, gy_ok, gz_ok = False, False, False
        ready = 0
        
        while True:
            try:
                self.setAccelOffsets(ax_offset, ay_offset, az_offset)
                self.setGyroOffsets(gx_offset, gy_offset, gz_offset)
                mean_ax, mean_ay, mean_az, mean_gx, mean_gy, mean_gz = meanSensors(self)
                
                if not ax_ok:
                    if abs(mean_ax) <= accel_deadzone:
                        ready += 1
                        ax_ok = True
                        print('ax_offset ready')
                    else:
                        ax_offset = ax_offset-mean_ax//accel_deadzone
                
                if not ay_ok:
                    if abs(mean_ay) <= accel_deadzone:
                        ready += 1
                        ay_ok = True
                        print('ay_offset ready')
                    else:
                        ay_offset = ay_offset-mean_ay//accel_deadzone
                
                if not az_ok:
                    if abs(16384-mean_az) <= accel_deadzone:
                        ready += 1
                        az_ok = True
                        print('az_offset ready')
                    else:
                        az_offset = az_offset+(16384-mean_az)//accel_deadzone
                
                if not gx_ok:
                    if abs(mean_gx) <= gyro_deadzone:
                        ready += 1
                        gx_ok = True
                        print('gx_offset ready')
                    else:
                        gx_offset = gx_offset-mean_gx//(gyro_deadzone+1)
                
                if not gy_ok:
                    if abs(mean_gy) <= gyro_deadzone:
                        ready += 1
                        gy_ok = True
                        print('gy_offset ready')
                    else:
                        gy_offset = gy_offset-mean_gy//(gyro_deadzone+1)
                
                if not gz_ok:
                    if abs(mean_gz) <= gyro_deadzone:
                        ready += 1
                        gz_ok = True
                        print('gz_offset ready')
                    else:
                        gz_offset = gz_offset-mean_gz//(gyro_deadzone+1)
                
                print('ax:{:5d} ay:{:5d} az:{:5d} gx:{:5d} gy:{:5d} gz:{:5d}'.format(ax_offset, ay_offset, az_offset, gx_offset, gy_offset, gz_offset))
                
                if ready==6:
                    print('******* MPU6050 calibration  end')
                    break
                
            except KeyboardInterrupt:
                print('******* MPU6050 calibration interruption')
                print('Offsets set to        ax:{:5d} ay:{:5d} az:{:5d} gx:{:5d} gy:{:5d} gz:{:5d}'.format(
                      self.getXAccelOffset(), self.getYAccelOffset(), self.getZAccelOffset(),
                      self.getXGyroOffset(), self.getYGyroOffset(), self.getZGyroOffset()))
                break
